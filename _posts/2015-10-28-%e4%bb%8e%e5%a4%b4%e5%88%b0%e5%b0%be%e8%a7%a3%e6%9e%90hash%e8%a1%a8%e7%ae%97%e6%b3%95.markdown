---
layout: post
title: 从头到尾解析Hash表算法
date: 2015-10-28 21:34:28.000000000 -04:00
categories:
- Reading Notes
- Hash
author: Jason
---
<p><a href="https://en.wikipedia.org/wiki/Hash_table">wikipedia</a></p>
<ul>
<li>哈希表hashtable(key，value) 的做法其实很简单，就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里。而当使用哈希表进行查询的时候，就是再次使用哈希函数将key转换为对应的数组下标，并定位到该空间获取value，如此一来，就可以充分利用到数组的定位性能进行数据定位</li>
<li>hash就是找到一种数据内容和数据存放地址之间的映射关系</li>
<li>元素特征转变为数组下标的方法就是散列法。散列法当然不止一种，下面列出三种比较常用的：
<ul>
<li>除法散列法<br />
最直观的一种，上图使用的就是这种散列法，公式：<br />
index = value % 16<br />
学过汇编的都知道，求模数其实是通过一个除法运算得到的，所以叫“除法散列法”。</li>
<li>平方散列法<br />
求index是非常频繁的操作，而乘法的运算要比除法来得省时（对现在的CPU来说，估计我们感觉不出来），所以我们考虑把除法换成乘法和一个位移操作。公式：<br />
index = (value * value) &gt;&gt; 28   （右移，除以2^28。记法：左移变大，是乘。右移变小，是除。）<br />
如果数值分配比较均匀的话这种方法能得到不错的结果，但我上面画的那个图的各个元素的值算出来的index都是0——非常失败。也许你还有个问题，value如果很大，value * value不会溢出吗？答案是会的，但我们这个乘法不关心溢出，因为我们根本不是为了获取相乘结果，而是为了获取index。</li>
<li>斐波那契（Fibonacci）散列法<br />
平方散列法的缺点是显而易见的，所以我们能不能找出一个理想的乘数，而不是拿value本身当作乘数呢？答案是肯定的。<br />
1，对于16位整数而言，这个乘数是40503<br />
2，对于32位整数而言，这个乘数是2654435769<br />
3，对于64位整数而言，这个乘数是11400714819323198485<br />
对我们常见的32位整数而言，公式：<br />
    index = (value * 2654435769) &gt;&gt; 28</li>
</ul>
</li>
<li>碰撞处理(collision)
<ul>
<li><a href="http://www.algolist.net/Data_structures/Hash_table/Chaining">open hashing(closed addresssing)</a>: none of the objects are actually stored in the hash table's array; instead once an object is hashed, it is stored in a list which is separate from the hash table's internal array. "open" refers to the freedom we get by leaving the hash table, and using a separate list. By the way, "separate list" hints at why open hashing is also known as "separate chaining".</li>
<li><a href="http://www.algolist.net/Data_structures/Hash_table/Open_addressing">closed hashing(opened addressing)</a>: The "closed" in "closed hashing" refers to the fact that we never leave the hash table; every object is stored directly at an index in the hash table's internal array. Note that this is only possible by using some sort of open addressing strategy. This explains why "closed hashing" and "open addressing" are synonyms. When hash table is based on the open addressing strategy, all key-value pairs are stored in the hash table itself and there is no need for external data structure.</li>
</ul>
</li>
<li>d-left hashing中的d是多个的意思，我们先简化这个问题，看一看2-left hashing。2-left hashing指的是将一个哈希表分成长度相等的两半，分别叫做T1和T2，给T1和T2分别配备一个哈希函数，h1和h2。在存储一个新的key时，同 时用两个哈希函数进行计算，得出两个地址h1[key]和h2[key]。这时需要检查T1中的h1[key]位置和T2中的h2[key]位置，哪一个 位置已经存储的（有碰撞的）key比较多，然后将新key存储在负载少的位置。如果两边一样多，比如两个位置都为空或者都存储了一个key，就把新key 存储在左边的T1子表中，2-left也由此而来。在查找一个key时，必须进行两次hash，同时查找两个位置。</li>
<li>哈希表的数组是定长的，如果太大，则浪费，如果太小，体现不出效率。合适的数组大小是哈希表的性能的关键。哈希表的尺寸最好是一个质数。当然，根据不同的数据量，会有不同的哈希表的大小。对于数据量时多时少的应用，最好的设计是使用动态可变尺寸的哈希表，那么如果你发现哈希表尺寸太小了，比如其中的元素是哈希表尺寸的2倍时，我们就需要扩大哈希表尺寸，一般是扩大一倍。</li>
</ul>
<p>&lt;</p>
<p><a href="http://blog.csdn.net/v_JULY_v/article/details/6256463">Read more</a></p>
