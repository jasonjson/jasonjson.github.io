---
layout: post
title: Unique Binary Search Trees
date: 2015-10-21 02:36:32.000000000 -04:00
type: post
published: true
status: publish
categories:
- Binary Search Tree
- Dynamic Programming
tags: []
meta:
  _wpcom_is_markdown: '1'
  _edit_last: '1'
  _spost_short_title: ''
  _jetpack_related_posts_cache: a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1467524042;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:333;}i:1;a:1:{s:2:"id";i:194;}i:2;a:1:{s:2:"id";i:165;}}}}
author:
  login: johnny.lyy@gmail.com
  email: johnny.lyy@gmail.com
  display_name: johnny.lyy@gmail.com
  first_name: ''
  last_name: ''
---
<p><strong><em>Given n, how many structurally unique BST's (binary search trees) that store values 1...n?</em></strong><br />
<a href="http://fisherlei.blogspot.com/2013/03/leetcode-unique-binary-search-trees.html">see more explanation here</a><br />
[expand title="code"]</p>
<pre>
public class Solution {
    /**
     * @paramn n: An integer
     * @return: An integer
     */
    public int numTrees(int n) {
        // write your code here
        if (n < 0) return -1;
        int[] count = new int[n+1]; //count[i] indicates how many BST for i
        count[0] = 1;
        for (int i = 1; i <= n; i++) {//there can be i - 1 elements in the subtree, use j to control how many elements in left subtree and how many in right subtree, update count[i]
            for (int j = 1; j <= i; j++) {
                count[i] += count[j-1] * count[i-j];// (j - 1) + (i - j) == i - 1 elements
            }
        }
        return count[n];
    }
}
</pre>
<p>[/expand]</p>
