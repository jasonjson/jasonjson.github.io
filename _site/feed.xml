<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xml" href="http://localhost:4000/feed.xslt.xml"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.3.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2017-01-01T10:52:08-05:00</updated><id>http://localhost:4000//</id><title type="html">Coding is fun</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.
</subtitle><entry><title type="html">Welcome to Jason!</title><link href="http://localhost:4000/jekyll/update/2016/12/30/welcome-to-jason.html" rel="alternate" type="text/html" title="Welcome to Jason!" /><published>2016-12-30T21:45:40-05:00</published><updated>2016-12-30T21:45:40-05:00</updated><id>http://localhost:4000/jekyll/update/2016/12/30/welcome-to-jason</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2016/12/30/welcome-to-jason.html">&lt;p&gt;You’ll find this post in your &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;, which launches a web server and auto-regenerates your site when a file is updated.&lt;/p&gt;

&lt;p&gt;To add new posts, simply add a file in the &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory that follows the convention &lt;code class=&quot;highlighter-rouge&quot;&gt;YYYY-MM-DD-name-of-post.ext&lt;/code&gt; and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.&lt;/p&gt;

&lt;p&gt;Jekyll also offers powerful support for code snippets:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hi, &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Tom'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#=&amp;gt; prints 'Hi, Tom' to STDOUT.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Check out the &lt;a href=&quot;http://jekyllrb.com/docs/home&quot;&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;Jekyll’s GitHub repo&lt;/a&gt;. If you have questions, you can ask them on &lt;a href=&quot;https://talk.jekyllrb.com/&quot;&gt;Jekyll Talk&lt;/a&gt;.&lt;/p&gt;</content><summary type="html">You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.</summary></entry><entry><title type="html">Welcome to Jekyll!</title><link href="http://localhost:4000/jekyll/update/2016/12/29/welcome-to-jekyll.html" rel="alternate" type="text/html" title="Welcome to Jekyll!" /><published>2016-12-29T21:45:40-05:00</published><updated>2016-12-29T21:45:40-05:00</updated><id>http://localhost:4000/jekyll/update/2016/12/29/welcome-to-jekyll</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2016/12/29/welcome-to-jekyll.html">&lt;p&gt;You’ll find this post in your &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;, which launches a web server and auto-regenerates your site when a file is updated.&lt;/p&gt;

&lt;p&gt;To add new posts, simply add a file in the &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory that follows the convention &lt;code class=&quot;highlighter-rouge&quot;&gt;YYYY-MM-DD-name-of-post.ext&lt;/code&gt; and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.&lt;/p&gt;

&lt;p&gt;Jekyll also offers powerful support for code snippets:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hi, &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Tom'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#=&amp;gt; prints 'Hi, Tom' to STDOUT.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Check out the &lt;a href=&quot;http://jekyllrb.com/docs/home&quot;&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;Jekyll’s GitHub repo&lt;/a&gt;. If you have questions, you can ask them on &lt;a href=&quot;https://talk.jekyllrb.com/&quot;&gt;Jekyll Talk&lt;/a&gt;.&lt;/p&gt;</content><summary type="html">You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.</summary></entry><entry><title type="html">Largest BST Subtree</title><link href="http://localhost:4000/binary%20search%20tree/brain%20teaser/2016/02/23/largest-bst-subtree.html" rel="alternate" type="text/html" title="Largest BST Subtree" /><published>2016-02-23T22:38:07-05:00</published><updated>2016-02-23T22:38:07-05:00</updated><id>http://localhost:4000/binary%20search%20tree/brain%20teaser/2016/02/23/largest-bst-subtree</id><content type="html" xml:base="http://localhost:4000/binary%20search%20tree/brain%20teaser/2016/02/23/largest-bst-subtree.html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;Given a binary tree, find the largest subtree which is a Binary Search Tree (BST), where largest means subtree with largest number of nodes in it.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[expand title=&quot;code&quot;]&lt;/p&gt;
&lt;pre&gt;
public class Solution {
    public int largestBSTSubtree(TreeNode root) {
        int[] result = helper(root);
        return result[1];
    }
    public int[] helper(TreeNode root) {
        int[] result = new int[5];
        //result[0]: is BST? result[2] : total number of nodes, result[3]: maximum value, result[4] minimum value
        result[0] = 1; result[3] = Integer.MIN_VALUE; result[4] = Integer.MAX_VALUE;
        if (root == null) return result;
        int[] result_left = helper(root.left);
        int[] result_right = helper(root.right);
        if (result_left[0] == 0 || result_right[0] == 0 || root.val &amp;gt;= result_right[4] || root.val &amp;lt;= result_left[3]) {
            result[0] = 0;
        }//root is larger than the biggest node in left subtree and smaller than smallest node in right subtree
        result[2] = result_left[2] + result_right[2] + 1;
        result[1] = result[0] == 1 ? result[2] : Math.max(result_left[1], result_right[1]);
        result[3] = Math.max(root.val, Math.max(result_left[3], result_right[3]));
        result[4] = Math.min(root.val, Math.min(result_left[4], result_right[4]));
        return result;
    }
}
&lt;/pre&gt;
&lt;p&gt;[/expand]&lt;/p&gt;</content><author><name>{&quot;login&quot;=&gt;&quot;johnny.lyy@gmail.com&quot;, &quot;email&quot;=&gt;&quot;johnny.lyy@gmail.com&quot;, &quot;display_name&quot;=&gt;&quot;johnny.lyy@gmail.com&quot;, &quot;first_name&quot;=&gt;&quot;&quot;, &quot;last_name&quot;=&gt;&quot;&quot;}</name><email>johnny.lyy@gmail.com</email></author><summary type="html">Given a binary tree, find the largest subtree which is a Binary Search Tree (BST), where largest means subtree with largest number of nodes in it.
[expand title=&quot;code&quot;]

public class Solution {
    public int largestBSTSubtree(TreeNode root) {
        int[] result = helper(root);
        return result[1];
    }
    public int[] helper(TreeNode root) {
        int[] result = new int[5];
        //result[0]: is BST? result[2] : total number of nodes, result[3]: maximum value, result[4] minimum value
        result[0] = 1; result[3] = Integer.MIN_VALUE; result[4] = Integer.MAX_VALUE;
        if (root == null) return result;
        int[] result_left = helper(root.left);
        int[] result_right = helper(root.right);
        if (result_left[0] == 0 || result_right[0] == 0 || root.val &amp;gt;= result_right[4] || root.val &amp;lt;= result_left[3]) {
            result[0] = 0;
        }//root is larger than the biggest node in left subtree and smaller than smallest node in right subtree
        result[2] = result_left[2] + result_right[2] + 1;
        result[1] = result[0] == 1 ? result[2] : Math.max(result_left[1], result_right[1]);
        result[3] = Math.max(root.val, Math.max(result_left[3], result_right[3]));
        result[4] = Math.min(root.val, Math.min(result_left[4], result_right[4]));
        return result;
    }
}

[/expand]</summary></entry><entry><title type="html">Verify Preorder Serialization of a Binary Tree</title><link href="http://localhost:4000/algorithms/brain_teaser/2016/02/23/verify-preorder-serialization-of-a-binary-tree.html" rel="alternate" type="text/html" title="Verify Preorder Serialization of a Binary Tree" /><published>2016-02-23T21:32:19-05:00</published><updated>2016-02-23T21:32:19-05:00</updated><id>http://localhost:4000/algorithms/brain_teaser/2016/02/23/verify-preorder-serialization-of-a-binary-tree</id><content type="html" xml:base="http://localhost:4000/algorithms/brain_teaser/2016/02/23/verify-preorder-serialization-of-a-binary-tree.html">&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Solution&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//the number of empty is nodes is always one more than the number of numeric nodes in the end&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isValidSerialization&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;preorder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;preorder&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;preorder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nodes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;preorder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;,&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nodes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//if there are still more nodes and the number of empty nodes&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// is already one more than the numeric node, return false&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;#&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//in the end, the number of empty node should be one more than the numeric nodes&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</content><summary type="html">``` java
public class Solution {
//the number of empty is nodes is always one more than the number of numeric nodes in the end
    public static boolean isValidSerialization(String preorder) {
        if (preorder == null || preorder.length() == 0) return false;</summary></entry><entry><title type="html">Increasing Triplet Subsequence</title><link href="http://localhost:4000/brain%20teaser/2016/02/22/increasing-triplet-subsequence.html" rel="alternate" type="text/html" title="Increasing Triplet Subsequence" /><published>2016-02-22T23:25:30-05:00</published><updated>2016-02-22T23:25:30-05:00</updated><id>http://localhost:4000/brain%20teaser/2016/02/22/increasing-triplet-subsequence</id><content type="html" xml:base="http://localhost:4000/brain%20teaser/2016/02/22/increasing-triplet-subsequence.html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[expand title=&quot;DP, O(n^2) time&quot;]&lt;/p&gt;
&lt;pre&gt;
public class Solution {
    public boolean increasingTriplet(int[] nums) {
        if (nums == null || nums.length == 0) return false;
        
        int n = nums.length;
        int[] dp = new int[n];
        Arrays.fill(dp, 1);
        for (int i = 1; i &amp;lt; n; i++) {
            for (int j = i - 1; j &amp;gt;= 0; j--) {
                if (nums[i] &amp;gt; nums[j]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
                if (dp[i] &amp;gt;= 3) {
                    return true;
                }
            }
        }
        return false;
    }
}
&lt;/pre&gt;
&lt;p&gt;[/expand]&lt;/p&gt;
&lt;p&gt;[expand title = &quot;O(n)&quot;]&lt;/p&gt;
&lt;pre&gt;
public class Solution {
    public boolean increasingTriplet(int[] nums) {
        if (nums == null || nums.length == 0) return false;
        
        int min = Integer.MAX_VALUE, secondMin = Integer.MAX_VALUE;
        for (int num : nums) {
            if (num &amp;lt;= min) {
                min = num;//we need to include &quot;=&quot; here, otherwise secondMin might get updated when num == min
            } else if (num &amp;lt; secondMin) {
                secondMin = num;
            } else if (num &amp;gt; secondMin) {
                return true;
            }
        }
        return false;
    }
}
&lt;/pre&gt;
&lt;p&gt;[/expand]&lt;/p&gt;</content><author><name>{&quot;login&quot;=&gt;&quot;johnny.lyy@gmail.com&quot;, &quot;email&quot;=&gt;&quot;johnny.lyy@gmail.com&quot;, &quot;display_name&quot;=&gt;&quot;johnny.lyy@gmail.com&quot;, &quot;first_name&quot;=&gt;&quot;&quot;, &quot;last_name&quot;=&gt;&quot;&quot;}</name><email>johnny.lyy@gmail.com</email></author><summary type="html">Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array.
[expand title=&quot;DP, O(n^2) time&quot;]

public class Solution {
    public boolean increasingTriplet(int[] nums) {
        if (nums == null || nums.length == 0) return false;
        
        int n = nums.length;
        int[] dp = new int[n];
        Arrays.fill(dp, 1);
        for (int i = 1; i &amp;lt; n; i++) {
            for (int j = i - 1; j &amp;gt;= 0; j--) {
                if (nums[i] &amp;gt; nums[j]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
                if (dp[i] &amp;gt;= 3) {
                    return true;
                }
            }
        }
        return false;
    }
}

[/expand]
[expand title = &quot;O(n)&quot;]

public class Solution {
    public boolean increasingTriplet(int[] nums) {
        if (nums == null || nums.length == 0) return false;
        
        int min = Integer.MAX_VALUE, secondMin = Integer.MAX_VALUE;
        for (int num : nums) {
            if (num &amp;lt;= min) {
                min = num;//we need to include &quot;=&quot; here, otherwise secondMin might get updated when num == min
            } else if (num &amp;lt; secondMin) {
                secondMin = num;
            } else if (num &amp;gt; secondMin) {
                return true;
            }
        }
        return false;
    }
}

[/expand]</summary></entry><entry><title type="html">Reconstruct Itinerary</title><link href="http://localhost:4000/dfs%20backtracking/2016/02/22/reconstruct-itinerary.html" rel="alternate" type="text/html" title="Reconstruct Itinerary" /><published>2016-02-22T22:26:53-05:00</published><updated>2016-02-22T22:26:53-05:00</updated><id>http://localhost:4000/dfs%20backtracking/2016/02/22/reconstruct-itinerary</id><content type="html" xml:base="http://localhost:4000/dfs%20backtracking/2016/02/22/reconstruct-itinerary.html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[expand title=&quot;code&quot;]&lt;/p&gt;
&lt;pre&gt;
public class Solution {
        public static List&lt;string&gt; findItinerary(String[][] tickets) {
        List&lt;string&gt; result = new ArrayList&amp;lt;&amp;gt;();
        if (tickets == null || tickets.length == 0) return result;

        Map&amp;lt;String, List&lt;string&gt;&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        for (String[] ticket : tickets) {
            List&lt;string&gt; arrival = map.containsKey(ticket[0]) ? map.get(ticket[0]) : new ArrayList&amp;lt;&amp;gt;();
            arrival.add(ticket[1]);
            map.put(ticket[0], arrival);
        }
        for (List&lt;string&gt; arrivals : map.values()) {
            Collections.sort(arrivals);
        }
        result.add(&quot;JFK&quot;);
        helper(map, result, &quot;JFK&quot;, tickets.length + 1);
        return result;
    }

    public static boolean helper(Map&amp;lt;String, List&lt;string&gt;&amp;gt; map, List&lt;string&gt; path, String last, int stops) {
        if (path.size() == stops) {
            return true;
        }
        if (!map.containsKey(last) || map.get(last).size() == 0) return false;
        List&lt;string&gt; arrivals = map.get(last);
        for (int i = 0; i &amp;lt; arrivals.size(); i++) {
            String next = map.get(last).remove(i);
            path.add(next);
            if (helper(map, path, next, stops)) {
                return true;
            }
            path.remove(path.size() - 1);
            arrivals.add(i, next);//be aware of concurrency problem
        }
        return false;
    }
}
&lt;/string&gt;&lt;/string&gt;&lt;/string&gt;&lt;/string&gt;&lt;/string&gt;&lt;/string&gt;&lt;/string&gt;&lt;/string&gt;&lt;/pre&gt;
&lt;p&gt;[/expand]&lt;/p&gt;</content><author><name>{&quot;login&quot;=&gt;&quot;johnny.lyy@gmail.com&quot;, &quot;email&quot;=&gt;&quot;johnny.lyy@gmail.com&quot;, &quot;display_name&quot;=&gt;&quot;johnny.lyy@gmail.com&quot;, &quot;first_name&quot;=&gt;&quot;&quot;, &quot;last_name&quot;=&gt;&quot;&quot;}</name><email>johnny.lyy@gmail.com</email></author><summary type="html">Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK.
[expand title=&quot;code&quot;]

public class Solution {
        public static List findItinerary(String[][] tickets) {
        List result = new ArrayList&amp;lt;&amp;gt;();
        if (tickets == null || tickets.length == 0) return result;</summary></entry><entry><title type="html">Patching Array</title><link href="http://localhost:4000/brain%20teaser/2016/01/27/patching-array.html" rel="alternate" type="text/html" title="Patching Array" /><published>2016-01-27T14:15:01-05:00</published><updated>2016-01-27T14:15:01-05:00</updated><id>http://localhost:4000/brain%20teaser/2016/01/27/patching-array</id><content type="html" xml:base="http://localhost:4000/brain%20teaser/2016/01/27/patching-array.html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;Given a sorted positive integer array nums and an integer n, add/patch elements to the array such that any number in range [1, n] inclusive can be formed by the sum of some elements in the array. Return the minimum number of patches required.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[expand title=&quot;code1&quot;]&lt;/p&gt;
&lt;pre&gt;
//Let miss be the smallest sum in [1,n] that we might be missing. Meaning we already know we can build all sums in [1,miss). Then if we have a number num &amp;lt;= miss in the given array, we can add it to those smaller sums to build all sums in [1,miss+num). If we don't, then we must add such a number to the array, and it's best to add miss itself, to maximize the reach.
public class Solution {
    public int minPatches(int[] nums, int n) {
        long miss = 1;
        int result = 0, i = 0;
        while (miss &amp;lt;= n) {
            if (i &amp;lt; nums.length &amp;amp;&amp;amp; nums[i] &amp;lt;= miss) {
                miss += nums[i++];
            } else {
                miss += miss;
                result ++;
            }
        }
        return result;
    }
}
&lt;/pre&gt;
&lt;p&gt;[/expand]&lt;/p&gt;
&lt;p&gt;[expand title=&quot;code2&quot;]&lt;/p&gt;
&lt;pre&gt;
public class Solution {
    public int minPatches(int[] nums, int n) {
        if (nums == null || nums.length == 0) return 0;

        HashMap&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        helper(nums, 0, 0, map);
        List&lt;integer&gt; missing = new ArrayList&amp;lt;&amp;gt;();
        for (int i = 1; i &amp;lt;= n; i++) {
            if (!map.containsKey(i)) {
                missing.add(i);
            }
        }
        int result = 0;
        for (int miss : missing) {
            if (!map.containsKey(miss)) {
                result++;
                List&lt;integer&gt; elements = new ArrayList&amp;lt;&amp;gt;();
                elements.addAll(map.keySet());
                for (int key : elements) {
                    map.put(key + miss, 1);
                }
            }
        }
        return result;
    }

    public void helper(int[] nums, int start, int sum, HashMap&amp;lt;Integer, Integer&amp;gt;map) {
        if (sum != 0) {
            map.put(sum, 1);
        }
        for (int i = start; i &amp;lt; nums.length; i++) {
            helper(nums, i + 1, sum + nums[i], map);
        }
    }
}
&lt;/integer&gt;&lt;/integer&gt;&lt;/pre&gt;
&lt;p&gt;[/expand]&lt;/p&gt;</content><author><name>{&quot;login&quot;=&gt;&quot;johnny.lyy@gmail.com&quot;, &quot;email&quot;=&gt;&quot;johnny.lyy@gmail.com&quot;, &quot;display_name&quot;=&gt;&quot;johnny.lyy@gmail.com&quot;, &quot;first_name&quot;=&gt;&quot;&quot;, &quot;last_name&quot;=&gt;&quot;&quot;}</name><email>johnny.lyy@gmail.com</email></author><summary type="html">Given a sorted positive integer array nums and an integer n, add/patch elements to the array such that any number in range [1, n] inclusive can be formed by the sum of some elements in the array. Return the minimum number of patches required.
[expand title=&quot;code1&quot;]

//Let miss be the smallest sum in [1,n] that we might be missing. Meaning we already know we can build all sums in [1,miss). Then if we have a number num &amp;lt;= miss in the given array, we can add it to those smaller sums to build all sums in [1,miss+num). If we don't, then we must add such a number to the array, and it's best to add miss itself, to maximize the reach.
public class Solution {
    public int minPatches(int[] nums, int n) {
        long miss = 1;
        int result = 0, i = 0;
        while (miss &amp;lt;= n) {
            if (i &amp;lt; nums.length &amp;amp;&amp;amp; nums[i] &amp;lt;= miss) {
                miss += nums[i++];
            } else {
                miss += miss;
                result ++;
            }
        }
        return result;
    }
}

[/expand]
[expand title=&quot;code2&quot;]

public class Solution {
    public int minPatches(int[] nums, int n) {
        if (nums == null || nums.length == 0) return 0;</summary></entry><entry><title type="html">Reorder String</title><link href="http://localhost:4000/brain%20teaser/2016/01/21/reorder-string.html" rel="alternate" type="text/html" title="Reorder String" /><published>2016-01-21T21:26:55-05:00</published><updated>2016-01-21T21:26:55-05:00</updated><id>http://localhost:4000/brain%20teaser/2016/01/21/reorder-string</id><content type="html" xml:base="http://localhost:4000/brain%20teaser/2016/01/21/reorder-string.html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;BACCBBAAA -&amp;gt; ABABACABC，就是输出相邻字母不能相同的string&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[expand title=&quot;code&quot;]&lt;/p&gt;
&lt;pre&gt;
public class Solution {
    public static void main(String[] args) {
        System.out.println(reOrder(&quot;BACCBBAAAACBACBAD&quot;));
    }
    public static String reOrder(String s) {
        if (s == null || s.length() == 0) return &quot;&quot;;

        HashMap&amp;lt;Character, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        for (char c : s.toCharArray()) {
            map.put(c, map.getOrDefault(c, 0) + 1);
        }
        PriorityQueue&lt;character&gt; pq = new PriorityQueue&amp;lt;&amp;gt;(10, new Comparator&lt;character&gt;() {
            @Override
            public int compare(Character o1, Character o2) {
                return map.get(o2) - map.get(o1);
            }
        });
        StringBuilder sb = new StringBuilder();
        for (char c : map.keySet()) {
            pq.offer(c);
        }
        while (!pq.isEmpty()) {//每次poll出频率最大的两个字符，如果还没用完就塞回去，如果频率相同，heap应该是按照入列顺序排序，这样就保证了如果剩余字符频率都一样的话，刚用过的字符肯定在最后
            char c1 = pq.poll();
            sb.append(c1);
            if (pq.isEmpty()) {
                break;
            }
            char c2 = pq.poll();
            sb.append(c2);
            map.put(c1, map.get(c1) - 1);
            map.put(c2, map.get(c2) - 1);
            if (map.get(c1) &amp;gt; 0) {
                pq.offer(c1);
            }
            if (map.get(c2) &amp;gt; 0) {
                pq.offer(c2);
            }
        }
        return sb.toString();
    }
}
&lt;/character&gt;&lt;/character&gt;&lt;/pre&gt;
&lt;p&gt;[/expand]&lt;/p&gt;</content><author><name>{&quot;login&quot;=&gt;&quot;johnny.lyy@gmail.com&quot;, &quot;email&quot;=&gt;&quot;johnny.lyy@gmail.com&quot;, &quot;display_name&quot;=&gt;&quot;johnny.lyy@gmail.com&quot;, &quot;first_name&quot;=&gt;&quot;&quot;, &quot;last_name&quot;=&gt;&quot;&quot;}</name><email>johnny.lyy@gmail.com</email></author><summary type="html">BACCBBAAA -&amp;gt; ABABACABC，就是输出相邻字母不能相同的string
[expand title=&quot;code&quot;]

public class Solution {
    public static void main(String[] args) {
        System.out.println(reOrder(&quot;BACCBBAAAACBACBAD&quot;));
    }
    public static String reOrder(String s) {
        if (s == null || s.length() == 0) return &quot;&quot;;</summary></entry><entry><title type="html">Validate UTF-8 byte sequence,</title><link href="http://localhost:4000/data%20structure/2016/01/21/validate-utf-8-byte-sequence.html" rel="alternate" type="text/html" title="Validate UTF-8 byte sequence," /><published>2016-01-21T12:09:57-05:00</published><updated>2016-01-21T12:09:57-05:00</updated><id>http://localhost:4000/data%20structure/2016/01/21/validate-utf-8-byte-sequence</id><content type="html" xml:base="http://localhost:4000/data%20structure/2016/01/21/validate-utf-8-byte-sequence.html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-8#Description&quot;&gt;Reference&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[expand title=&quot;code&quot;]&lt;/p&gt;
&lt;pre&gt;
public class Solution {
    public static boolean validate(byte[] bytes) {
        int expectedLen;
        if (bytes.length == 0) {
            return false;
        } else if ((bytes[0] &amp;amp; 0b10000000) == 0b00000000) {
            expectedLen = 1;
        } else if ((bytes[0] &amp;amp; 0b11100000) == 0b11000000) {
            expectedLen = 2;
        } else if ((bytes[0] &amp;amp; 0b11110000) == 0b11100000) {
            expectedLen = 3;
        } else if ((bytes[0] &amp;amp; 0b11111000) == 0b11110000) {
            expectedLen = 4;
        } else if ((bytes[0] &amp;amp; 0b11111100) == 0b11111000) {
            expectedLen = 5;
        } else if ((bytes[0] &amp;amp; 0b11111110) == 0b11111100) {
            expectedLen = 6;
        } else {
            return false;
        }
        if (expectedLen != bytes.length) {
            return false;
        }
        for (int i = 1; i &amp;lt; bytes.length; i++) {
            if ((bytes[i] &amp;amp; 0b11000000) != 0b10000000) {
                return false;
            }
        }
        return true;
    }
}
&lt;/pre&gt;
&lt;p&gt;[/expand]&lt;/p&gt;</content><author><name>{&quot;login&quot;=&gt;&quot;johnny.lyy@gmail.com&quot;, &quot;email&quot;=&gt;&quot;johnny.lyy@gmail.com&quot;, &quot;display_name&quot;=&gt;&quot;johnny.lyy@gmail.com&quot;, &quot;first_name&quot;=&gt;&quot;&quot;, &quot;last_name&quot;=&gt;&quot;&quot;}</name><email>johnny.lyy@gmail.com</email></author><summary type="html">Reference
[expand title=&quot;code&quot;]

public class Solution {
    public static boolean validate(byte[] bytes) {
        int expectedLen;
        if (bytes.length == 0) {
            return false;
        } else if ((bytes[0] &amp;amp; 0b10000000) == 0b00000000) {
            expectedLen = 1;
        } else if ((bytes[0] &amp;amp; 0b11100000) == 0b11000000) {
            expectedLen = 2;
        } else if ((bytes[0] &amp;amp; 0b11110000) == 0b11100000) {
            expectedLen = 3;
        } else if ((bytes[0] &amp;amp; 0b11111000) == 0b11110000) {
            expectedLen = 4;
        } else if ((bytes[0] &amp;amp; 0b11111100) == 0b11111000) {
            expectedLen = 5;
        } else if ((bytes[0] &amp;amp; 0b11111110) == 0b11111100) {
            expectedLen = 6;
        } else {
            return false;
        }
        if (expectedLen != bytes.length) {
            return false;
        }
        for (int i = 1; i &amp;lt; bytes.length; i++) {
            if ((bytes[i] &amp;amp; 0b11000000) != 0b10000000) {
                return false;
            }
        }
        return true;
    }
}

[/expand]</summary></entry><entry><title type="html">Find the difference between two set</title><link href="http://localhost:4000/brain%20teaser/2016/01/21/find-the-difference-between-two-set.html" rel="alternate" type="text/html" title="Find the difference between two set" /><published>2016-01-21T11:30:59-05:00</published><updated>2016-01-21T11:30:59-05:00</updated><id>http://localhost:4000/brain%20teaser/2016/01/21/find-the-difference-between-two-set</id><content type="html" xml:base="http://localhost:4000/brain%20teaser/2016/01/21/find-the-difference-between-two-set.html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;找出两个数组的差，比如A = [1,1,1,2,2,2], B= [2,2,3]，在A出现在B不出现的集合是[1,1,1,2]， 在B出现在A    不出现的集合是[3]&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[expand title=&quot;code&quot;]&lt;/p&gt;
&lt;pre&gt;
public class Solution {
    public static void main(String[] args) {
        List&lt;integer&gt; A = new ArrayList&amp;lt;&amp;gt;(Arrays.asList(1,1,1,2,2,2));
        List&lt;integer&gt; B = new ArrayList&amp;lt;&amp;gt;(Arrays.asList(2,2,3));
        System.out.println(findSubset(B, A));
        System.out.println(findSubset(A, B));
    }
    public static List&lt;integer&gt; findSubset(List&lt;integer&gt; A, List&lt;integer&gt; B) {
        List&lt;integer&gt; result = new ArrayList&amp;lt;&amp;gt;();
        if (A.size() == 0) return result;
        if (B.size() == 0) {
            result.addAll(A);
            return result;
        }
        HashMap&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        for (int num : A) {
            map.put(num, map.getOrDefault(num, 0) + 1);
        }
        for (int num : B) {
            if (map.containsKey(num)) {
                map.put(num, map.get(num) - 1);
            }
        }
        for (int num : map.keySet()) {
            for (int i = 0; i &amp;lt; map.get(num); i++) {
                result.add(num);
            }
        }
        return result;
    }
}
&lt;/integer&gt;&lt;/integer&gt;&lt;/integer&gt;&lt;/integer&gt;&lt;/integer&gt;&lt;/integer&gt;&lt;/pre&gt;
&lt;p&gt;[/expand]&lt;/p&gt;</content><author><name>{&quot;login&quot;=&gt;&quot;johnny.lyy@gmail.com&quot;, &quot;email&quot;=&gt;&quot;johnny.lyy@gmail.com&quot;, &quot;display_name&quot;=&gt;&quot;johnny.lyy@gmail.com&quot;, &quot;first_name&quot;=&gt;&quot;&quot;, &quot;last_name&quot;=&gt;&quot;&quot;}</name><email>johnny.lyy@gmail.com</email></author><summary type="html">找出两个数组的差，比如A = [1,1,1,2,2,2], B= [2,2,3]，在A出现在B不出现的集合是[1,1,1,2]， 在B出现在A    不出现的集合是[3]
[expand title=&quot;code&quot;]

public class Solution {
    public static void main(String[] args) {
        List A = new ArrayList&amp;lt;&amp;gt;(Arrays.asList(1,1,1,2,2,2));
        List B = new ArrayList&amp;lt;&amp;gt;(Arrays.asList(2,2,3));
        System.out.println(findSubset(B, A));
        System.out.println(findSubset(A, B));
    }
    public static List findSubset(List A, List B) {
        List result = new ArrayList&amp;lt;&amp;gt;();
        if (A.size() == 0) return result;
        if (B.size() == 0) {
            result.addAll(A);
            return result;
        }
        HashMap&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        for (int num : A) {
            map.put(num, map.getOrDefault(num, 0) + 1);
        }
        for (int num : B) {
            if (map.containsKey(num)) {
                map.put(num, map.get(num) - 1);
            }
        }
        for (int num : map.keySet()) {
            for (int i = 0; i &amp;lt; map.get(num); i++) {
                result.add(num);
            }
        }
        return result;
    }
}

[/expand]</summary></entry></feed>
